
#include <Arduino.h>

uint32_t mp_hal_ticks_us(void);
__attribute__((always_inline)) static inline uint32_t mp_hal_ticks_cpu(void)
{
    uint32_t ccount;
    __asm__ __volatile__("rsr %0,ccount" : "=a"(ccount));
    return ccount;
}

void IRAM_ATTR esp_neopixel_write(uint8_t pin, uint8_t *pixels, uint32_t numBytes, uint8_t timing)
{
    uint8_t *p, *end, pix, mask;
    uint32_t t, time0, time1, period, c, startTime, pinMask;

    pinMask = 1 << pin;
    p = pixels;
    end = p + numBytes;
    pix = *p++;
    mask = 0x80;
    startTime = 0;

    uint32_t fcpu = ets_get_cpu_frequency() * 1000000;

    if (timing == 1)
    {
        // 800 KHz
        time0 = (fcpu * 0.35) / 1000000;  // 0.35us
        time1 = (fcpu * 0.8) / 1000000;   // 0.8us
        period = (fcpu * 1.25) / 1000000; // 1.25us per bit
    }
    else
    {
        // 400 KHz
        time0 = (fcpu * 0.5) / 1000000;  // 0.35us
        time1 = (fcpu * 1.2) / 1000000;  // 0.8us
        period = (fcpu * 2.5) / 1000000; // 1.25us per bit
    }

    uint32_t irq_state = portENTER_CRITICAL_NESTED();
    for (t = time0;; t = time0)
    {
        if (pix & mask)
            t = time1; // Bit high duration
        while (((c = mp_hal_ticks_cpu()) - startTime) < period)
            ;                                       // Wait for bit start
        GPIO_REG_WRITE(GPIO_OUT_W1TS_REG, pinMask); // Set high
        startTime = c;                              // Save start time
        while (((c = mp_hal_ticks_cpu()) - startTime) < t)
            ;                                       // Wait high duration
        GPIO_REG_WRITE(GPIO_OUT_W1TC_REG, pinMask); // Set low
        if (!(mask >>= 1))
        { // Next bit/byte
            if (p >= end)
                break;
            pix = *p++;
            mask = 0x80;
        }
    }
    while ((mp_hal_ticks_cpu() - startTime) < period)
        ; // Wait for last bit
    portEXIT_CRITICAL_NESTED(irq_state);
}

#define LedPower 2
#define LedCtrl  4

#define BitRed 0
#define BitGreen 1
#define BitBlue 2

#define BitFillArea(Led, Size, View, Color) for(uint32_t x = 0, t = View; x < Size; x++) memset(&Led[x * 3], 0, 3), Led[x * 3 + Color[x / 5]] = (t & 1) * 5, t >>= 1

#define BitFillNext(View, Next) View <<= 5, View |= Next

const uint8_t WordLib[][5] = {

    /*   [0x0020]    5x5  */
    {0x00,0x00,0x00,0x00,0x00,},

    /*  ![0x0021]    5x5  */
    {0x00,0x00,0x17,0x00,0x00,},
    
    /*  "[0x0022]    5x5  */
    {0x00,0x07,0x00,0x07,0x00,},
    
    /*  #[0x0023]    5x5  */
    {0x0A,0x1F,0x0A,0x1F,0x0A,},
    
    /*  $[0x0024]    5x5  */
    {0x12,0x15,0x03,0x15,0x09,},
    
    /*  %[0x0025]    5x5  */
    {0x13,0x0B,0x04,0x1A,0x19,},
    
    /*  &[0x0026]    5x5  */
    {0x1B,0x15,0x0B,0x14,0x00,},
    
    /*  '[0x0027]    5x5  */
    {0x00,0x05,0x03,0x00,0x00,},
    
    /*  ([0x0028]    5x5  */
    {0x00,0x0E,0x11,0x00,0x00,},
    
    /*  )[0x0029]    5x5  */
    {0x00,0x00,0x11,0x0E,0x00,},
    
    /*  *[0x002A]    5x5  */
    {0x04,0x15,0x0E,0x15,0x04,},
    
    /*  +[0x002B]    5x5  */
    {0x04,0x04,0x1F,0x04,0x04,},
    
    /*  ,[0x002C]    5x5  */
    {0x00,0x14,0x0C,0x00,0x00,},
    
    /*  -[0x002D]    5x5  */
    {0x04,0x04,0x04,0x04,0x04,},
    
    /*  .[0x002E]    5x5  */
    {0x00,0x18,0x18,0x00,0x00,},
    
    /*  /[0x002F]    5x5  */
    {0x10,0x08,0x04,0x02,0x01,},
    
    /*  0[0x0030]    5x5  */
    {0x0E,0x19,0x15,0x13,0x0E,},
    
    /*  1[0x0031]    5x5  */
    {0x00,0x12,0x1F,0x10,0x00,},
    
    /*  2[0x0032]    5x5  */
    {0x12,0x19,0x1D,0x17,0x12,},
    
    /*  3[0x0033]    5x5  */
    {0x09,0x11,0x13,0x1D,0x09,},
    
    /*  4[0x0034]    5x5  */
    {0x0C,0x0A,0x09,0x1F,0x08,},
    
    /*  5[0x0035]    5x5  */
    {0x17,0x15,0x15,0x15,0x09,},
    
    /*  6[0x0036]    5x5  */
    {0x0E,0x15,0x15,0x15,0x08,},
    
    /*  7[0x0037]    5x5  */
    {0x01,0x01,0x1D,0x03,0x01,},
    
    /*  8[0x0038]    5x5  */
    {0x0A,0x15,0x15,0x15,0x0A,},
    
    /*  9[0x0039]    5x5  */
    {0x02,0x15,0x15,0x15,0x0E,},
    
    /*  :[0x003A]    5x5  */
    {0x00,0x1B,0x1B,0x00,0x00,},
    
    /*  ;[0x003B]    5x5  */
    {0x00,0x15,0x0D,0x00,0x00,},
    
    /*  <[0x003C]    5x5  */
    {0x00,0x04,0x0A,0x11,0x00,},
    
    /*  =[0x003D]    5x5  */
    {0x0A,0x0A,0x0A,0x0A,0x0A,},
    
    /*  >[0x003E]    5x5  */
    {0x00,0x11,0x0A,0x04,0x00,},
    
    /*  ?[0x003F]    5x5  */
    {0x00,0x01,0x15,0x03,0x00,},
    
    /*  @[0x0040]    5x5  */
    {0x08,0x15,0x1D,0x11,0x0E,},
    
    /*  A[0x0041]    5x5  */
    {0x1E,0x05,0x05,0x05,0x1E,},
    
    /*  B[0x0042]    5x5  */
    {0x1F,0x15,0x15,0x15,0x0A,},
    
    /*  C[0x0043]    5x5  */
    {0x0E,0x11,0x11,0x11,0x0A,},
    
    /*  D[0x0044]    5x5  */
    {0x1F,0x11,0x11,0x11,0x0E,},
    
    /*  E[0x0045]    5x5  */
    {0x1F,0x15,0x15,0x15,0x11,},
    
    /*  F[0x0046]    5x5  */
    {0x1F,0x05,0x05,0x01,0x00,},
    
    /*  G[0x0047]    5x5  */
    {0x0E,0x11,0x11,0x15,0x0C,},
    
    /*  H[0x0048]    5x5  */
    {0x1F,0x04,0x04,0x04,0x1F,},
    
    /*  I[0x0049]    5x5  */
    {0x00,0x11,0x1F,0x11,0x00,},
    
    /*  J[0x004A]    5x5  */
    {0x08,0x10,0x11,0x0F,0x01,},
    
    /*  K[0x004B]    5x5  */
    {0x1F,0x04,0x0A,0x11,0x00,},
    
    /*  L[0x004C]    5x5  */
    {0x1F,0x10,0x10,0x10,0x10,},
    
    /*  M[0x004D]    5x5  */
    {0x1F,0x01,0x02,0x01,0x1F,},
    
    /*  N[0x004E]    5x5  */
    {0x1F,0x02,0x04,0x08,0x1F,},
    
    /*  O[0x004F]    5x5  */
    {0x0E,0x11,0x11,0x11,0x0E,},
    
    /*  P[0x0050]    5x5  */
    {0x1F,0x05,0x05,0x05,0x02,},
    
    /*  Q[0x0051]    5x5  */
    {0x0E,0x11,0x15,0x09,0x16,},
    
    /*  R[0x0052]    5x5  */
    {0x1F,0x05,0x0D,0x15,0x12,},
    
    /*  S[0x0053]    5x5  */
    {0x12,0x15,0x15,0x15,0x09,},
    
    /*  T[0x0054]    5x5  */
    {0x01,0x01,0x1F,0x01,0x01,},
    
    /*  U[0x0055]    5x5  */
    {0x0F,0x10,0x10,0x10,0x0F,},
    
    /*  V[0x0056]    5x5  */
    {0x07,0x08,0x10,0x08,0x07,},
    
    /*  W[0x0057]    5x5  */
    {0x1F,0x08,0x06,0x08,0x1F,},
    
    /*  X[0x0058]    5x5  */
    {0x11,0x0A,0x04,0x0A,0x11,},
    
    /*  Y[0x0059]    5x5  */
    {0x01,0x02,0x1C,0x02,0x01,},
    
    /*  Z[0x005A]    5x5  */
    {0x11,0x19,0x15,0x13,0x11,},
    
    /*  [[0x005B]    5x5  */
    {0x00,0x00,0x1F,0x11,0x11,},
    
    /*  \[0x005C]    5x5  */
    {0x01,0x02,0x04,0x08,0x10,},
    
    /*  ][0x005D]    5x5  */
    {0x11,0x11,0x1F,0x00,0x00,},
    
    /*  ^[0x005E]    5x5  */
    {0x04,0x02,0x01,0x02,0x04,},
    
    /*  _[0x005F]    5x5  */
    {0x10,0x10,0x10,0x10,0x10,},
    
    /*  `[0x0060]    5x5  */
    {0x00,0x01,0x02,0x04,0x00,},
    
    /*  a[0x0061]    5x5  */
    {0x08,0x15,0x15,0x15,0x0E,},
    
    /*  b[0x0062]    5x5  */
    {0x0F,0x14,0x12,0x12,0x0C,},
    
    /*  c[0x0063]    5x5  */
    {0x0E,0x11,0x11,0x11,0x08,},
    
    /*  d[0x0064]    5x5  */
    {0x0C,0x12,0x12,0x14,0x1F,},
    
    /*  e[0x0065]    5x5  */
    {0x0E,0x15,0x15,0x15,0x06,},
    
    /*  f[0x0066]    5x5  */
    {0x04,0x1E,0x05,0x01,0x02,},
    
    /*  g[0x0067]    5x5  */
    {0x02,0x05,0x15,0x15,0x0E,},
    
    /*  h[0x0068]    5x5  */
    {0x1F,0x04,0x02,0x02,0x1C,},
    
    /*  i[0x0069]    5x5  */
    {0x00,0x14,0x1D,0x10,0x00,},
    
    /*  j[0x006A]    5x5  */
    {0x08,0x10,0x11,0x0D,0x00,},
    
    /*  k[0x006B]    5x5  */
    {0x00,0x1F,0x04,0x0A,0x10,},
    
    /*  l[0x006C]    5x5  */
    {0x00,0x11,0x1F,0x10,0x00,},
    
    /*  m[0x006D]    5x5  */
    {0x1E,0x02,0x0C,0x02,0x1C,},
    
    /*  n[0x006E]    5x5  */
    {0x1E,0x04,0x02,0x02,0x1C,},
    
    /*  o[0x006F]    5x5  */
    {0x0E,0x11,0x11,0x11,0x0E,},
    
    /*  p[0x0070]    5x5  */
    {0x1F,0x05,0x05,0x05,0x06,},
    
    /*  q[0x0071]    5x5  */
    {0x02,0x05,0x05,0x06,0x1F,},
    
    /*  r[0x0072]    5x5  */
    {0x1F,0x02,0x01,0x01,0x02,},
    
    /*  s[0x0073]    5x5  */
    {0x12,0x15,0x15,0x15,0x08,},
    
    /*  t[0x0074]    5x5  */
    {0x02,0x0F,0x12,0x10,0x08,},
    
    /*  u[0x0075]    5x5  */
    {0x0F,0x10,0x10,0x08,0x1F,},
    
    /*  v[0x0076]    5x5  */
    {0x07,0x08,0x10,0x08,0x07,},
    
    /*  w[0x0077]    5x5  */
    {0x0F,0x10,0x08,0x10,0x0F,},
    
    /*  x[0x0078]    5x5  */
    {0x11,0x0A,0x04,0x0A,0x11,},
    
    /*  y[0x0079]    5x5  */
    {0x03,0x14,0x14,0x14,0x0F,},
    
    /*  z[0x007A]    5x5  */
    {0x11,0x19,0x15,0x13,0x11,},
    
    /*  {[0x007B]    5x5  */
    {0x04,0x0E,0x1F,0x11,0x00,},
    
    /*  |[0x007C]    5x5  */
    {0x00,0x00,0x1F,0x00,0x00,},
    
    /*  }[0x007D]    5x5  */
    {0x00,0x11,0x1F,0x0E,0x04,},
    
    /*  ~[0x007E]    5x5  */
    {0x02,0x01,0x02,0x04,0x02,},
    
    /*  [0x007F]    5x5  */
    {0x1F,0x1F,0x1F,0x1F,0x1F,},
};

inline void BitShow(uint8_t word[5], uint8_t Color[5] = {0})
{
    uint8_t tmp[25 * 3] = { };
    uint32_t View = 0;
    
    for(int i = 0; i < 5; i++)
    {
        BitFillNext(View, word[i]);

        BitFillArea(tmp, 25, View, Color);
    }
    esp_neopixel_write(LedCtrl, tmp, sizeof(tmp), 1);
}

inline void __BitShow(uint8_t buf[], uint len, uint delay)
{
    // printf("len %d\n", len);
    uint8_t tmp[25 * 3] = { };
    uint32_t View = 0;
    uint8_t Color[5] = {0}, Temp = 0;

    for(int i = 0; i < len; i++)
    {
        if(0 == (i % 6)) Temp = (Temp + 1) % 3;

        for(int i = 4; i > 0; i--) Color[i] = Color[i - 1];

        Color[0] = Temp;
        
        BitFillNext(View, buf[i]);

        BitFillArea(tmp, 25, View, Color);

        esp_neopixel_write(LedCtrl, tmp, sizeof(tmp), 1);

        vTaskDelay(delay / portTICK_PERIOD_MS);

        // printf("i %d\n", i);
    }
}

inline bool BitScroll(char data[], uint datalen, uint delay = 200)
{
    uint8_t *result = (uint8_t *)calloc((datalen + 2) * 6, sizeof(*result));
    if(result)
    {
        for(int i = 1; i < datalen + 1; i++)
        {
            memcpy(result + (i*6), WordLib[data[i - 1] - 0x20], 5);
        }
        __BitShow(result, (datalen + 2) * 6, delay);
        free(result);
        return true;
    }
    return false;
}

inline void BitScroll(uint8_t data[], uint datalen, uint delay = 200)
{
    __BitShow(data, datalen, delay);
}

inline void BitLedOpen()
{
    pinMode(2, OUTPUT);
    digitalWrite(2, HIGH);
    pinMode(4, OUTPUT);

}

inline void BitLedExit()
{
    digitalWrite(2, LOW);
}
